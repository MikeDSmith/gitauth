#!/usr/bin/env ruby
require File.join(File.dirname(__FILE__), "..", "lib", "gitauth")

GitAuth::Application.processing(ARGV) do |a|
  a.banner = "GitAuth v#{GitAuth.version}"
  
  a.generator!
  
  a.option(:force, "force the creation of the settings file")
  a.option(:admin, "pass the path to a ssh public key and it adds a default admin user")
  a.add("install", "Sets up GitAuth for the current user") do |options|
    
    setup_generator ".", :silent => true
    
    # Check for a valid admin key
    if options.has_key?(:admin) && (!options[:admin].is_a?(String) || !file?(options[:admin]))
      puts "You provided the admin option but didn't provide it with a path to public key."
      die! "Please re-run again with a path to a key, e.g. --admin=~/id_rsa.pub"
    end
    
    if !yes?("Are you logged in as the correct user?")
      die!("Please log in as the correct user and re-run") 
    end

    if !GitAuth.has_git?
      die!("'git' was not found in your path - please install it / add it to your path before continuing.")
    end

    ssh_folder = "~/.ssh"
    if !folder?(ssh_folder)
      folders ssh_folder
      chmod 0700, ssh_folder
    end

    authorized_keys = ssh_folder / "authorized_keys"
    if !file?(authorized_keys)
      file authorized_keys, "\n\n## GitAuth - DO NO EDIT BELOW THIS LINE ##\n"
      chmod 0600, authorized_keys
    end

    gitauth_folder = "~/.gitauth/"
    folders gitauth_folder

    settings_file = gitauth_folder / "settings.yml"
    if !file?(settings_file) || options[:force]
      repo_path = ask("Where did you want repositories to be stored?", "~/repositories")
      repo_path = File.expand_path(repo_path)
      folders repo_path

      default_shell_path = GitAuth::BASE_DIR.join("bin", "gitauth-shell").to_s
      gitauth_shell_path = ""
      gitauth_shell_set  = false
      while gitauth_shell_path.blank? || !(file?(gitauth_shell_path) && executable?(gitauth_shell_path))
        # A Give the user a message if the path doesn't exist.
        if gitauth_shell_set
          puts "The shell you provided, #{gitauth_shell_path}, isn't executable"
        else
          gitauth_shell_set = true
        end
        gitauth_shell_path = ask("What is the path to your gitauth-shell?", default_shell_path)
        gitauth_shell_path = File.expand_path(gitauth_shell_path)
      end

      GitAuth::Settings.update!({
        :base_path            => File.expand_path(repo_path),
        :authorized_keys_file => File.expand_path(authorized_keys),
        :shell_executable     => File.expand_path(gitauth_shell_path)
      })
    end

    if options[:admin]
      
    end
    
  end

  a.controller! :web_app, "Starts the gitauth frontend using the default sintra runner"
  
  a.option(:force, "Skip the verification / confirmation part of adding the permissions")
  a.option(:type, "The type of permissions - one of all, read, write or none. Defaults to all")
  full_desc = "Gives a specific user or group the specified permissions to a given repository - pass '-h' for more information"
  a.add("permissions REPOSITORY USER-OR-GROUP", full_desc) do |repo, target, options|
    permissions = options[:type] || 'all'
    
    if !%w(all read write none).include? permissions
      die! "'#{permissions}' is not a valid permission type. It must be all, read, write or none"
    end
    
    real_permissions = ({"all" => ["read", "write"], "none" => []}[permissions] || [permissions])
    repository       = GitAuth::Repo.get(repo)
    real_target      = GitAuth.get_user_or_group(target)
    
    die! "Unknown repository '#{repo}'"      if repository.blank?
    die! "Unknown user or group '#{target}'" if real_target.blank?
    
    if options[:force] || yes?("Adding '#{permissions}' permissions for #{real_target} to #{repository.name}")
      repository.update_permissions!(real_target, real_permissions)
      puts "Permissions updated."
    else
      puts "Permissions not added, exiting."
    end
  end
  
  # a.add "add-group NAME", "Creates a group with a given name" do |name, options|
  #   GitAuth.prepare
  # end
  
  #a.add "add-user NAME PATH-TO-PUBLIC-KEY", "Creates a user with a given public key"
  
  #a.add "add-repo NAME [PATH=NAME]", "Creates a named repository, with an optional path on the file system"
  
end